% Initial Class for PPI
classdef ImageDisplayPPI < ImageDisplayBase
    properties                                                                      
        m_hSweepPatch;
        m_sweepGradientAngle = 1.5*pi/180;
        m_pixelOrigin;
        % added following to support electronic azimuth steering
        m_hSweepSteerPatch;
    end
    methods
        function obj = ImageDisplayPPI(nPixels,maxRange,azSweepFlag)
             % call base class
             obj = obj@ImageDisplayBase(nPixels,nPixels,-maxRange,maxRange,-maxRange,maxRange);
             % set labels
             set(get(obj.m_hAxisHandle,'XLabel'),'String','East (km)');
             set(get(obj.m_hAxisHandle,'YLabel'),'String','North (km)');
             % set default axis
             set(obj.m_hAxisHandle,'XGrid','off','YGrid','off');
             obj.updateRangeTicks(round(maxRange/5));
             % sweep line
             obj.m_hSweepPatch = patch();
             set(obj.m_hSweepPatch, ...
                  'XData',[ 0 0 0 0], ...
                  'YData',[ 0 0 0 0], ...
                  'Clipping','off',...
                  'EdgeColor','none', ...
                  'FaceColor',[0 .75 0]);
              if ( nargin == 3 )
                  if ( azSweepFlag == 1 )
                      obj.m_hSweepSteerPatch = patch();
                      set(obj.m_hSweepSteerPatch, ...
                          'XData',[ 0 0 0 0], ...
                          'YData',[ 0 0 0 0], ...
                          'Clipping','off',...
                          'EdgeColor','none', ...
                          'FaceColor',[0 .25 0]);
                  end
              end
             % ppi should be square
             set(obj.m_hAxisHandle,'DataAspectRatioMode','manual', ...
                  'DataAspectRatio',[1 1 1]);
        end
        function updateRangeTicks(this,rangeStep)
             this.updateHorizontalTicks(rangeStep,1e-3);
             this.updateVerticalTicks(rangeStep,1e-3);
             % range rings
             aRing = [0:0.05:(2*pi+0.1)];
             rRing = rangeStep:rangeStep:this.m_max_y_col_engineeringUnit;
             %hold on;
             %set(this.m_hAxisHandle,'NextPlot','add');
             for kring = 1:length(rRing)
                 plot(this.m_hAxisHandle,rRing(kring)*sin(aRing),rRing(kring)*cos(aRing),'Color',[0 this.m_axisLineBrightness 0],'LineStyle','-');
             end
        end
        function setPixel(this,rngM,azRad,RGB) % intensity 0-255
             azRad = mod(azRad + 4*pi,2*pi);
             this.setPixel@ImageDisplayBase(rngM*sin(azRad),rngM*cos(azRad),RGB);
        end
        function setSweepPosition(this,azRad,azSteer)
             x1 = this.m_sweepGradientAngle/2;
             set(this.m_hSweepPatch, ...
                 'YData',  ...
                 [0 this.m_max_y_col_engineeringUnit*cos(azRad-x1), ...
                    this.m_max_y_col_engineeringUnit*cos(azRad+x1) 0], ...
                 'XData', ...
                 [0 this.m_max_y_col_engineeringUnit*sin(azRad-x1), ...
                    this.m_max_y_col_engineeringUnit*sin(azRad+x1) 0]);
             if ( nargin == 3 )
             set(this.m_hSweepSteerPatch, ...
                 'YData',  ...
                 [0 this.m_max_y_col_engineeringUnit*cos(azRad+azSteer-x1), ...
                    this.m_max_y_col_engineeringUnit*cos(azRad+azSteer+x1) 0], ...
                 'XData', ...
                 [0 this.m_max_y_col_engineeringUnit*sin(azRad+azSteer-x1), ...
                    this.m_max_y_col_engineeringUnit*sin(azRad+azSteer+x1) 0]);
             end
        end
        function setPatchOverlay(this,ID,rng,az,halfspan,RGBONE,thickness) % input in eu
            this.setPatchOverlay@ImageDisplayBase(ID, ...
                 rng*sin(az)-halfspan, ...
                 rng*sin(az)+halfspan, ...
                 rng*cos(az)-halfspan, ...
                 rng*cos(az)+halfspan, ...
                 RGBONE,thickness);
        end
        function setPlotOverlay(this,ID,range,azRad,RGBONE,markerstring,markersize)
            this.setPlotOverlay@ImageDisplayBase(ID,range*sin(azRad),range*cos(azRad),RGBONE,markerstring.markersize);
        end
    end
end
